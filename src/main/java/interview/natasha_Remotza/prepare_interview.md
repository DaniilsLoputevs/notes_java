Основные моменты
* Работа с БД, Spring JPA, Построение БД
* Мультинодовость (конкурентные процессы, их синхронизация)
* основы Spring

Любят собес строить так: 
1) какие были проекты, 
2) далее общие вопросы про спринг, 
3) * далее могут либо дать код на рефакторинг,
4) * либо дать практические вопросы.

Общие вопросы любят такие:
1) жц бина:
   * Какие скоупы бинов бывают? Каков жц каждого скоупа?
     * Singleton - Единственный экземпляр бина на весь Spring context. (@Lazy - делает загрузку Ленивой)
     * Prototype - Создаётся новый экземпляр бина каждый раз при вызове `context.getBean("beanNameWithPorotypeScope")`
     * Request - Создаётся один экземпляр бина на каждый HTTP запрос.
     * Session - Создаётся один экземпляр бина на каждую HTTP сессию.
     * websocket - 
     * application - 
   * Как можно определить бины?
     * annotation context
     * XML context
     * Java coode context
   * Для создания бина требуется выполнить последовательность шагов (init метод). Как можно это реализовать
     1) Чтение всех Бин конфигурация(annotation, Java code, XML)
     2) Создание BeanDefinition из прочитанных конфигов
     3) Создание всех `BeanFactoryPostProcessor` & `BeanPostProcessor`
     4) Создание и настройка каждого Singleton Бина (если он не @Conditional(~false~) || @Lazy)
        - СОЗДАНИЕ БИНА
        - BeanFactory создает Объект bean из оригинального класса.
        - dependency inject через Конструктор и Setter
        - каждый BeanPostProcessor обрабатывает бин через вызов метода `postProcessBeforeInitialization(bean)`
        - вызывается метод(ы) помеченные `@PostConstruct`
        - каждый BeanPostProcessor обрабатывает бин через вызов метода `postProcessAfterInitialization (bean)`
        - УНИЧТОЖЕНИЕ БИНА (only Singlton)
        - `@PreDestroy`
        - метод public close() или shutdown(), автоматически становятся методами уничтожения.
   * Как можно получить прототип (и его производные) из контекста?
     * `context.getBean("beanNameWithPorotypeScope")`
   * Как разрешить кофликтующие зависимости (2 бина реализуют общий интерфейс)?
     * `@Qualifier`
     * `@Primary`

2) прокси, транзакции и jpa (обычно не вопросы на прямую, а в рамках задачки или рефакторинга)
   * Как использовать транзакционный метод в компоненте-владельце (self-inject)
   * Необходимо имплементировать логгирование(историю или иное). Как лучше всего это сделать (вопрос про аспекты)
     * Spring AOP или Annotation + `BeanPostProcessor` 
   * В чем отличия сессии от транзакции
     * Session - может
        - Объект соединения с Базой
        - Factory для Transaction
        - делать низкоуровневые операции, что обычно является структурным кодом Framework
        - Кеш Сессии - Обширный Уровень
        - CRUD + native query + Criteria API
     * Transaction - может
       - открывать/закрывать Транзакции
       - Rollback
       - (Опция) Уровни Изоляции
       - (Опция) readOnly
       - (Опция) Блокировка (Optimistic & Pessimistic)
   * Как безопасно выполнить несколько запросов на чтение без записи?
     * Transaction ReadOnly
   * Что такое оптимистическая (пессиместическая) блокировки и как можно ее имплементировать в jpa
     * `@Version` ставиться на поле сущности и помечает его для технических нужд. (Optimistic lock)
     * Optimistic - Много Read & мало Write
        - Каждая транзакция при использовании данных, смотрит на поле помеченное `@Version` (Версия сущности)
        - При использовании каждая транзакция, которая считывает данные, содержит значение . 
        - Когда транзакция захочет выполнить обновление, она Снова прочитает (Версия сущности) и справнит со старым значение. 
        - Если за это время значение изменилось, создается исключение OptimisticLockException. 
        - Иначе транзакция фиксирует обновление и увеличивает значение свойства версии.
        - РЕЖИМЫ
        - OPTIMISTIC - он получает оптимистическую блокировку чтения для всех объектов, содержащих атрибут версии.
        - OPTIMISTIC_FORCE_INCREMENT — OPTIMISTIC + дополнительно увеличивает значение атрибута версии.
     * Pessimistic - мало Read & Много Write
       - PESSIMISTIC_READ — общая блокировка - предотвратит **Параллельное** `обновление` или `удаление` данных.
       - PESSIMISTIC_WRITE — эксклюзивная блокировка - предотвратить **Параллельное** `чтение`, `обновление` или `удаление` данных.
       - PESSIMISTIC_FORCE_INCREMENT — PESSIMISTIC_WRITE + дополнительно увеличивает значение атрибута версии.
   * Как реализовать поиск по сущности с динамическими фильтрами?
     * Spring Data methodName + method args
     * JPQL(HQL) + method args



3) Решение задач о распределенных процессах (почти всегда можно рассказать про quartz - используют свою доработку этой библиотеки)
    - Cкорее всего тут Комплекс вопросов - о Quartz, т.к. это основа для из framework
    - Возможно основная мысль - Расписания/ID начатых бизнес-процессов + начатый этап/ID сущности ИЛИ Запрос(идемпотентность)
    - НЕОБХОДИМО хранить Вне сервиса, например в: Kafka(message broker), Database, File system(юзать файл)
    - При начале процесса - проверять не взялся ли другой Экземпляр Сервиса за выполнение этого Расписания/Запроса.
   * Как в микросервисе реализовать процесс, уникальный в рамках сервиса (речь про эксклюзивные джобы)
     * требуется сторонние хранилище и там хранить лок на этот процесс(processId + status(STARTED или что-то такое))
   * Любая задача на синхронизацию операций между потоками (конкретных задач не смог вытянуть, но есть люди, которые это могут спросить) 
     * Quartz имеет возможность синхронизировать Расписания в БД и вообще работать в Кластерном режиме (https://habr.com/ru/companies/surfstudio/articles/685980/)
   * Как обеспечить идемпотентность для методов (Может быть задан в рамках POST запросов на создание)
   * Задачи о работе с очередями (любят кафку - нужно понимать что такое топик, партиции, консюмер группы)
П.с. Очень помогло видео(https://www.youtube.com/watch?v=oOyq4OXfCEc) - дало Полезное осознание на собесе - Подходы по достижения Идемпотентности.


4) Вопросы и задачи по БД
   * ACID
     * A - Atomic - действие Свершилось ИЛИ Нет - не может быть состояния, когда Действие завершилось Частично.    
     * С - Consistency(согласованность) - В случаи технических поломок, Данные не должны, нарушать бизнес-правила. 
       * Пример: Банковский Перевод 100$ со счёта А(100$) насчёт Б(0$).
       * Бизнес правило: деньги не должны списываться и начисляться более одного раза в случаи денежного-перевода.
       * Состояние когда у счёта А будет -200$ т.к. что-то сломалось - является Нарушение бизнес-правила, то есть Согласованности.
     * I - Isolation - Транзакции не должны влиять на другие Транзакции. (удовольствие дорогое - есть Уровни Изоляции)
     * D - Durability(Устойчивость) - Завершить транзакцию корректно, даже в случаи проблем на нижних уровнях(Отрубили электричество).
   * Объяснить уровни изоляции
   * ```
     + - Есть защита
| Уровень изоляции | Phantom read | Non-repeatable read | Dirty read | Lost update |
|------------------|--------------|---------------------|------------|-------------|
| READ UNCOMMITTED |              |                     |            | +           |
| READ COMMITTED   |              |                     | +          | +           |
| REPEATABLE READ  |              | +                   | +          | +           |
| SERIALIZABLE     | +            | +                   | +          | +           |
     ```
   * Есть таблица, для нее пишем селект с фильрами (where). Как нам обеспечить блокировку выбранных записей
     * Например, вешать `@Lock(LockModeType.PESSIMISTIC_WRITE)` на метод в классе Repository 
     * select for update || select for no key update
     * Уровни Изоляции в Транзакциях 
     * LOCK TABLE tableName IN SHARE ROW EXCLUSIVE MODE; (и другие режимы)
   * Могут попросить написать какой-нибудь запрос по постановке (с joinами, подстановочными знаками и пр)
   * В каких случаях нужно создавать индекс
     * Когда нужно оптимизировать запрос(ы) с where :parameter - делает Индекс на :parameter
   * Нормализация и денормализация данных - ЧтоГдеКогда
   * Как создать индекс для полнотекстового поиска (Gist Gin)


5) Алгоритмы (обычно дается код, и там нужно найти ошибку и исправить)
   * Дана рекурсия и при ее выполнении получаем StackOverFlow. Варианты решения
   * Исправьте (или расскажите) алгоритмы сортировки (чаще всего слышал про quick sort)
   * Исправьте (или расскажите) алгоритмы поиска (может быть что угодно. Двоичная считается моветоном)


6) Структуры данных (обычно идет с алгоритмами)
   * Разница между ArrayList и LinkedList
   * Дан кусок кода, где в HashMap кладут pojo с не корректно переопределенным hashCode
     * Правила hashCode
        - Идемпотентность при условии, что поля объекта, участвующие в вычислении значения, не изменялись.
        - если `equals()` вернул `true` то и `hashCode()` должен вернуть одинаковые значения


7) Организация кода (очень субъективный во многом пункт - надо уметь доказывать свою точку зрения так как среди опрошеных коллег единого мнения по многим вопросам не нашел)
   * Границы потребления сущностей (грубо говоря речь про возвращение сущностей из сервисов куда-либо. В контроллеры, например)
   * Дана jpa сущность, которая маппится на dto в контроллере. Сущность сложная и имеет коллекции. Какие могут быть решения?
   * 
   * Как и где провалидировать доступ и параметры для REST запросов (@PreAuthorize и контроллеры)

8) Основы REST
   * Любой вопрос про методы/заголовки/ограничения и пр
   * Приведите пример реализации операций API для сущности (например /document. Речь про уменее использовать https://restfulapi.net/resource-naming/)

9) Тестирование (спрашивают всегда, надо уметь ответить про Mokito что-нибудь с примером. Задач по тестам не дают)
10) Филосовские вопросы (почти никто не практикует. Вопросы из разряда - для чего нужен спринг)



Вопросы взяты из практики работы с OeBS отделом и у разработчиков из других команд. Всегда спрашивают с 1 по 4 пункты включительно. 
Остальное - как попадется.
Софтскильные советы - аргументируйте каждое решение. У ребят из Я политика - посмотреть как мыслит. 
Не соглашайтесь сразу на предложенное интервьювером решение взамен вашего - может быть ловушкой. Не молчите, рассуждайте в слух.

