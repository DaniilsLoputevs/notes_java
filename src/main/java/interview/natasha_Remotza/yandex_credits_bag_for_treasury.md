# Кредитный портфель для Казначейства

Слив по подготовке + конспект(что не расписано == могу сказать без конспекта).

<details>
  <summary>Click me</summary>

      Основные моменты
      * Работа с БД, Spring JPA, Построение БД
        * Мультинодовость (конкурентные процессы, их синхронизация)
        * основы Spring
      
      Любят собес строить так:
      1) какие были проекты,
         2) далее общие вопросы про спринг,
      3) * далее могут либо дать код на рефакторинг,
      4) * либо дать практические вопросы.
      
      Общие вопросы любят такие:
      1) жц бина:
         * Какие скоупы бинов бывают? Каков жц каждого скоупа?
            * Singleton - Единственный экземпляр бина на весь Spring context. (@Lazy - делает загрузку Ленивой)
            * Prototype - Создаётся новый экземпляр бина каждый раз при вызове `context.getBean("beanNameWithPorotypeScope")`
            * Request - Создаётся один экземпляр бина на каждый HTTP запрос.
            * Session - Создаётся один экземпляр бина на каждую HTTP сессию.
            * websocket -
            * application -
         * Как можно определить бины?
            * annotation context
            * XML context
            * Java coode context
         * Для создания бина требуется выполнить последовательность шагов (init метод). Как можно это реализовать
            1) Чтение всех Бин конфигурация(annotation, Java code, XML)
            2) Создание BeanDefinition из прочитанных конфигов
            3) Создание всех `BeanFactoryPostProcessor` & `BeanPostProcessor`
            4) Создание и настройка каждого Singleton Бина (если он не @Conditional(~false~) || @Lazy)
               - СОЗДАНИЕ БИНА
               - BeanFactory создает Объект bean из оригинального класса.
               - dependency inject через Конструктор и Setter
               - каждый BeanPostProcessor обрабатывает бин через вызов метода `postProcessBeforeInitialization(bean)`
               - вызывается метод(ы) помеченные `@PostConstruct`
               - каждый BeanPostProcessor обрабатывает бин через вызов метода `postProcessAfterInitialization (bean)`
               - УНИЧТОЖЕНИЕ БИНА (only Singlton)
               - `@PreDestroy`
               - метод public close() или shutdown(), автоматически становятся методами уничтожения.
         * Как можно получить прототип (и его производные) из контекста?
            * `context.getBean("beanNameWithPorotypeScope")`
         * Как разрешить кофликтующие зависимости (2 бина реализуют общий интерфейс)?
            * `@Qualifier`
            * `@Primary`
      
         2) прокси, транзакции и jpa (обычно не вопросы на прямую, а в рамках задачки или рефакторинга)
            * Как использовать транзакционный метод в компоненте-владельце (self-inject)
            * Необходимо имплементировать логгирование(историю или иное). Как лучше всего это сделать (вопрос про аспекты)
               * Spring AOP или Annotation + `BeanPostProcessor`
            * В чем отличия сессии от транзакции
               * Session - может
                  - Объект соединения с Базой
                  - Factory для Transaction
                  - делать низкоуровневые операции, что обычно является структурным кодом Framework
                  - Кеш Сессии - Обширный Уровень
                  - CRUD + native query + Criteria API
               * Transaction - может
                  - открывать/закрывать Транзакции
                  - Rollback
                  - (Опция) Уровни Изоляции
                  - (Опция) readOnly
                  - (Опция) Блокировка (Optimistic & Pessimistic)
            * Как безопасно выполнить несколько запросов на чтение без записи?
               * Transaction ReadOnly
            * Что такое оптимистическая (пессиместическая) блокировки и как можно ее имплементировать в jpa
               * `@Version` ставиться на поле сущности и помечает его для технических нужд. (Optimistic lock)
               * Optimistic - Много Read & мало Write
                  - Каждая транзакция при использовании данных, смотрит на поле помеченное `@Version` (Версия сущности)
                  - При использовании каждая транзакция, которая считывает данные, содержит значение .
                  - Когда транзакция захочет выполнить обновление, она Снова прочитает (Версия сущности) и справнит со старым значение.
                  - Если за это время значение изменилось, создается исключение OptimisticLockException.
                  - Иначе транзакция фиксирует обновление и увеличивает значение свойства версии.
                  - РЕЖИМЫ
                  - OPTIMISTIC - он получает оптимистическую блокировку чтения для всех объектов, содержащих атрибут версии.
                  - OPTIMISTIC_FORCE_INCREMENT — OPTIMISTIC + дополнительно увеличивает значение атрибута версии.
               * Pessimistic - мало Read & Много Write
                  - PESSIMISTIC_READ — общая блокировка - предотвратит **Параллельное** `обновление` или `удаление` данных.
                  - PESSIMISTIC_WRITE — эксклюзивная блокировка - предотвратить **Параллельное** `чтение`, `обновление` или `удаление` данных.
                  - PESSIMISTIC_FORCE_INCREMENT — PESSIMISTIC_WRITE + дополнительно увеличивает значение атрибута версии.
            * Как реализовать поиск по сущности с динамическими фильтрами?
               * Spring Data methodName + method args
               * JPQL(HQL) + method args
      
      
      
      3) Решение задач о распределенных процессах (почти всегда можно рассказать про quartz - используют свою доработку этой библиотеки)
         - Cкорее всего тут Комплекс вопросов - о Quartz, т.к. это основа для из framework
         - Возможно основная мысль - Расписания/ID начатых бизнес-процессов + начатый этап/ID сущности ИЛИ Запрос(идемпотентность)
         - НЕОБХОДИМО хранить Вне сервиса, например в: Kafka(message broker), Database, File system(юзать файл)
         - При начале процесса - проверять не взялся ли другой Экземпляр Сервиса за выполнение этого Расписания/Запроса.
         * Как в микросервисе реализовать процесс, уникальный в рамках сервиса (речь про эксклюзивные джобы)
            * требуется сторонние хранилище и там хранить лок на этот процесс(processId + status(STARTED или что-то такое))
         * Любая задача на синхронизацию операций между потоками (конкретных задач не смог вытянуть, но есть люди, которые это могут спросить)
            * Quartz имеет возможность синхронизировать Расписания в БД и вообще работать в Кластерном режиме (https://habr.com/ru/companies/surfstudio/articles/685980/)
         * Как обеспечить идемпотентность для методов (Может быть задан в рамках POST запросов на создание)
         * Задачи о работе с очередями (любят кафку - нужно понимать что такое топик, партиции, консюмер группы)
           П.с. Очень помогло видео(https://www.youtube.com/watch?v=oOyq4OXfCEc) - дало Полезное осознание на собесе - Подходы по достижения Идемпотентности.
      
      
      4) Вопросы и задачи по БД
         * ACID
            * A - Atomic - действие Свершилось ИЛИ Нет - не может быть состояния, когда Действие завершилось Частично.
            * С - Consistency(согласованность) - В случаи технических поломок, Данные не должны, нарушать бизнес-правила.
               * Пример: Банковский Перевод 100$ со счёта А(100$) насчёт Б(0$).
               * Бизнес правило: деньги не должны списываться и начисляться более одного раза в случаи денежного-перевода.
               * Состояние когда у счёта А будет -200$ т.к. что-то сломалось - является Нарушение бизнес-правила, то есть Согласованности.
            * I - Isolation - Транзакции не должны влиять на другие Транзакции. (удовольствие дорогое - есть Уровни Изоляции)
            * D - Durability(Устойчивость) - Завершить транзакцию корректно, даже в случаи проблем на нижних уровнях(Отрубили электричество).
         * Объяснить уровни изоляции
         * ```
           + - Есть защита
      | Уровень изоляции | Phantom read | Non-repeatable read | Dirty read | Lost update |
      |------------------|--------------|---------------------|------------|-------------|
      | READ UNCOMMITTED |              |                     |            | +           |
      | READ COMMITTED   |              |                     | +          | +           |
      | REPEATABLE READ  |              | +                   | +          | +           |
      | SERIALIZABLE     | +            | +                   | +          | +           |
           ```
      * Есть таблица, для нее пишем селект с фильрами (where). Как нам обеспечить блокировку выбранных записей
         * Например, вешать `@Lock(LockModeType.PESSIMISTIC_WRITE)` на метод в классе Repository
         * select for update || select for no key update
         * Уровни Изоляции в Транзакциях
         * LOCK TABLE tableName IN SHARE ROW EXCLUSIVE MODE; (и другие режимы)
        * Могут попросить написать какой-нибудь запрос по постановке (с joinами, подстановочными знаками и пр)
        * В каких случаях нужно создавать индекс
           * Когда нужно оптимизировать запрос(ы) с where :parameter - делает Индекс на :parameter
        * Нормализация и денормализация данных - ЧтоГдеКогда
        * Как создать индекс для полнотекстового поиска (Gist Gin)
      
      
      5) Алгоритмы (обычно дается код, и там нужно найти ошибку и исправить)
         * Дана рекурсия и при ее выполнении получаем StackOverFlow. Варианты решения
         * Исправьте (или расскажите) алгоритмы сортировки (чаще всего слышал про quick sort)
         * Исправьте (или расскажите) алгоритмы поиска (может быть что угодно. Двоичная считается моветоном)
      
      
      6) Структуры данных (обычно идет с алгоритмами)
         * Разница между ArrayList и LinkedList
         * Дан кусок кода, где в HashMap кладут pojo с не корректно переопределенным hashCode
            * Правила hashCode
               - Идемпотентность при условии, что поля объекта, участвующие в вычислении значения, не изменялись.
               - если `equals()` вернул `true` то и `hashCode()` должен вернуть одинаковые значения
      
      
      7) Организация кода (очень субъективный во многом пункт - надо уметь доказывать свою точку зрения так как среди опрошеных коллег единого мнения по многим вопросам не нашел)
         * Границы потребления сущностей (грубо говоря речь про возвращение сущностей из сервисов куда-либо. В контроллеры, например)
         * Дана jpa сущность, которая маппится на dto в контроллере. Сущность сложная и имеет коллекции. Какие могут быть решения?
         *
         * Как и где провалидировать доступ и параметры для REST запросов (@PreAuthorize и контроллеры)
      
         8) Основы REST
            * Любой вопрос про методы/заголовки/ограничения и пр
            * Приведите пример реализации операций API для сущности (например /document. Речь про уменее использовать https://restfulapi.net/resource-naming/)
      
         9) Тестирование (спрашивают всегда, надо уметь ответить про Mokito что-нибудь с примером. Задач по тестам не дают)
         10) Филосовские вопросы (почти никто не практикует. Вопросы из разряда - для чего нужен спринг)
      
      
      
      Вопросы взяты из практики работы с OeBS отделом и у разработчиков из других команд. Всегда спрашивают с 1 по 4 пункты включительно.
      Остальное - как попадется.
      Софтскильные советы - аргументируйте каждое решение. У ребят из Я политика - посмотреть как мыслит.
      Не соглашайтесь сразу на предложенное интервьювером решение взамен вашего - может быть ловушкой. Не молчите, рассуждайте в слух.
      

</details>

Рекомендации от HR(или кого-то ещё) за 1час до интервью. (Памятка для специалиста)
<details>
  <summary>Click me</summary>

В помощь для подготовки к интервью:
Памятка для специалиста.

Ключевые моменты:

- Интервью проходим от лица компании РогаКопыта (Читается РогаКопыта)
  (если спросят, то работаете здесь со старта последнего проекта).
- Не обсуждаем оплату (способ, размер).
- Если на собеседовании говорят, что есть возможность работать в офисе - отдаем предпочтение удаленке, без высадки в офис и командировок
- Подключаться на встречу с включенной камерой, только через личную почту/аккаунт. (желательно заранее проверить работоспособность своего оборудования)
- В интервью можно упоминать только бренды/названия проектов/продуктов, на которых вы работали, но не фактических работодателей.
- Рекомендуется заранее подготовить небольшой содержательный рассказ о себе и самому предложить рассказать, не дожидаясь когда собеседник попросит. В первую очередь, фокусируемся на том, что делали на последнем проекте.
- Быть готовым прокомментировать/ответить на вопрос: “расскажите о последних проектах и чем запомнились”. Примерный алгоритм: общее описание проекта (например, система отображения графиков), проблематика/фича (был затык с тем-то), решение (сделали так, интересная инженерная задача и т.д.). Будет полезно заранее подготовить некий тезисный план на бумаге и держать рядом, в качестве шпаргалки.
- Фриланс опыт и соло-разработка мало ценятся или даже негативно влияют на общую оценку. Поэтому любую практику просто упоминать без приписок фриланс/side/pet-проект, либо называть коммерческим опытом.
- Не ругать какие-то технологии, даже если они вам не очень нравятся.
- Если Ваш собеседник какие-то детали проекта рассказывает неохотно, скорее всего - проект NDA или он всего не знает. Не стоит на него давить.

Пожелания:
- Если не получается дать конкретный ответ на вопрос - не впадаем в ступор, а рассуждаем вслух: "Я бы реализовал это вот так, а это использую в таких-то случаях и т.д.". Иначе интервьюеры будут в фидбэке писать: “По софт скиллам - вслух не размышляет, пока его об этом не попросишь”.
- Если кажется, что на вопрос ответили, но боитесь что уже лишнего наговорите, то остановитесь и спросите "достаточно ли такого ответа"?
- Желательно спрашивать, как организована работа на проекте, какие задачи нужно будет решать именно тебе, какие библиотеки/инструменты будут использоваться. Это важно по двум причинам: положительно влияет на общее впечатление интервьюера, а также помогает специалисту понять, насколько этот проект отвечает целям и задачам по развитию своих навыков.
</details>

Ход Собеса
* шаг 1 - за 31 мин до назначенного времени собеса, мне через HR скинули линк на их платформу с онлайн кодом, а там ТЗ, сказано ВЫПОЛНИТЬ ДО СОБЕСА.
<details>
  <summary>Click me</summary>

```java
/*
 * В k8s крутится сервис, который обрабатывает платежи
 * В базу поступают задачи, шедуллер берет эти задачи и начинает обрабатывать и посылать в билинговую систему команду на выплату
 * Нужно провести ревью и написать комментарии, как бы вы исправили код
 * Доп. инфа:
        Не все приведённые комментарии были сделаны по ходу ТЗ - часть написана ПОСЛЕ собеса. 
        Экземпляров сервиса в k8s = 34+
        Шедулеры(Экземпляры сервисов) должны параллельно и Одновременно обрабатывать Платежи.
 */
@Service
@AllArgsConstructor
@Slf4j
public class SchedulerService {

   private final PaymentRepository paymentRepository;

   private final PaymentService paymentService;

   // Нет логики по Эксклюзивному Захвату данных - сейчас 2+ Шедулеров(Экземпляров сервиса) могут начать обрабатывать платежи с ид 1-10. (Это УЖАСНО)
   // Как чинить? - можно Брать записи со статусом NEW и Сразу же менять статус NEW -> PROCESSING (использовать что-то типа CAS операции или Локов БД на таблицу/записи)
   // Так мы обеспечим что Шедулер 1 захватит ид 1-10, Шедулер 2 захватит ид 11-20, Шедулер 3 захватит ид 21-20 и т.д.
   @Scheduled(fixedDelayString = "${payment.schedule.pending}", timeUnit = TimeUnit.SECONDS)
   private void getNextPaymentToSent() {
      List<Payment> paymentList = paymentRepository.findTop10ByOrderByIdAsc();
      // 1 - Логируются Чувствительные данные - прямо в лог печатается Номер паспорта и т.д..
      // 2 - лог может упасть на 
       // ИЛИ на hibernate Payment field Person has Lazy fetch and invoked outside of Transaction 
       // ИЛИ на (мало вероятно) SOF SOF из-за рекурсии. List<Payment>.toString() - Person.toString() - List<Payment>.toString() - Person.toString() - List<Payment>.toString()
      log.info("next payments to sent: {}", paymentList);
      paymentService.send(paymentList);
   }
}

@Service
@AllArgsConstructor
@Slf4j
public class PaymentService {
    
    // можно делать через Enum + вынести в отдельный класс - так удобнее расширять и читать код
   private final static String STATUS_NEW="NEW";
   // Зачем тут @Getter? оно уже public
   @Getter
   public final static String ERROR = "ERROR";

   private final BillingIntegrationService billingIntegrationService;
   private final PaymentRepository paymentRepository;

   // ИМХО - не очевидно зачем тут нужна аннотация @Async и думаю лучше сделать комментарий, ибо код читают и Джуны тоже.
    // Важно что бы, Поток выполняющий метод Шедулера - должен успеть выполнить его ДО времени следующего старта, иначе Шедулер пропустит запуск по второму времени.
    // вызов этого метода БЕЗ @Async - потенциально приведёт к достаточно Долгому выполнению задачи Шедулера, что плохо.
    // вызов этого метода С @Async - по сути перекладывает задачу с Шедулера(ThreadPool'а или даже класстер'а, если у нас включен Кластерный режим у либы Реализации @Scheduled - по умолчанию это Quartz если не ошибаюсь)
    // В итоге вызов этого метода == сабмитит Задачи(send(List<Payment> paymentList) + arg) в Очередь Задач в ThreadPool для Асинхронных запросов и Шедулер на этом СВОБОДЕН! он завершил свою работу быстро! Добби свободен!
   @Async
   public void send(List<Payment> paymentList) {
      // Зачем тут фильтр на статус когда это можно сделать в sql?
      // ИМХО - Stream для Константно 10 элементов? Видится что можно обойтись обычным forEach. Особенно, вынеся filter в sql.
      paymentList.stream().filter(payment -> payment.getStatus() == STATUS_NEW)
              .forEach(payment -> billingIntegrationService.sendPaymentToBilling(
                      payment.getPerson().getId(), payment.getSumm(),
                      payment.getPerson().getCartNum(), payment.getId()));
   }

   @Transactional
   public void setError(Long id, String exeption) {
      Payment payment = paymentRepository.getById(id);
      payment.setStatus(ERROR);
      payment.setException(exeption);
      // Бесполезный saveAndFlush - т.к. @Transactional сам это сделает после выполнения пользовательского метода.
      paymentRepository.saveAndFlush(payment);
      // можем (именно в этом месте ТОЧНО) упасть по SOF из-за рекурсии. Payment.toString() - Person.toString() - List<Payment>.toString() - Person.toString() - List<Payment>.toString()
      // @ManyToOne(fetch = FetchType.LAZY) private Person person; - тут не спасёт т.к. @Transactional и данные будут выгружатся.
      log.error("Ошибка, до этого были еще ошибки в платежах по клиенту: {}", getAllErrorPayment(payment.getId()));
   }

   // 1 - Итоговые данные метода - можно получить сразу из базы, переместим условия в sql select ... where *наши условия*. - так будет Быстрее и Проще.
   // 2 - судя по аннотациям Hibernate в класс Payment, у sql таблицы payments есть поле ссылка на запись в таблице persons.
   // Можно упростить условие до SELECT * FROM payments WHERE payments.person_id = id AND status == 'ERROR';
   private List<Payment> getAllErrorPayment(Long id) {
      return paymentRepository.getById(id).getPerson().getPaymentList().stream()
              .filter(s -> s.getStatus() != error).collect(Collectors.toList());
   }
}

/**
 * Сервис интеграции с билинговой системой, которая отправляет платежи в банк.
 */
@Service
@AllArgsConstructor
@Slf4j
public class BillingIntegrationService {

   @Value("${payment.uri}")
   private final String uri ;

   // а где dependency injection? Почему хард-код без комментариев? Почему всё так?
   private final RestTemplate restTemplate = new RestTemplate();

   private final PaymentService paymentService;

   // Где обработка Успешного кейса? Если Ошибка, то отметим что будет Err, а если всё ОК, нужно отметить что Успешно.
   // Иначе в след. раз, мы захватим эти же(фактически обработанные Платежи) и будем повторно их Исполнять.
   public void sendPaymentToBilling(Payment payment) {
      try {
         PaymentDTO paymentDTO = new PaymentDTO(person, summ, cartNum);
         PStatusDTO statusDTO = restTemplate.patchForObject(new URI(uri), paymentDTO, PStatusDTO.class);
         if (statusDTO.status() == paymentService.getError()) {
            paymentService.setError(id, statusDTO.error);
         }
      } catch (URISyntaxException e) {
         log.error("Ошибка URI", e);
         // Тут точно не нужно нормальной обработки?
         // RestTemplate может выкинуть не учтённые в catch ошибки
      }

   }

   private record PaymentDTO(
           String person,
           String sum,
           String cartNum
   ) {
   }

   private record PStatusDTO(
           String status,
           String error
   ) {
   }
}

// Заметка - @Repository и JpaRepository - дублируют друг друга, можно оставить только JpaRepository что бы были Методы из коробки.
@Repository
public interface PaymentRepository extends JpaRepository<Payment, Long> {
   List<Payment> findTop10ByOrderByIdAsc();
}

@Data
@Entity
public class Payment {

   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = "payment_id")
   private Long id;
   /**
    * тут стринг для простоты
    */
   @Column(nullable = false)
   private String status;
   /**
    * ошибка если есть
    */
   @Column
   String exception;
   /**
    * сумма платежа
    */
   @Column(nullable = false)
   private String summ;
   /**
    * кому платить
    */
   @ManyToOne(fetch = FetchType.LAZY)
   private Person person;
}

@Data
@Entity
public class Person {
   /**
    * серия номер паспорта
    */
   @Id
   @Column(name = "person_id")
   @ToString.Exclude
   private String id;

   // Чувствительные данные - минимум нужен @ToString.Exclude
   @Column(nullable = false)
   private String surname;

   // Чувствительные данные - минимум нужен @ToString.Exclude
   @Column(nullable = false)
   private String name;

   // Чувствительные данные - минимум нужен @ToString.Exclude
   @Column(nullable = false)
   private String patronymic;
   /**
    * номер карты
    */
   // Чувствительные данные - минимум нужен @ToString.Exclude
   @Column(nullable = false)
   private String cartNum;
   /**
    * тут стринг для простоты
    */
   @Column(nullable = false)
   private String modifier;

   @OneToMany(mappedBy = "person")
   private List<Payment> paymentList = new ArrayList<>();
}
```

</details>

   Зум конфа на 9 человек - одной пачкой собес на 2 разные позиции(Java dev & какой-то Аепс(хз что это такое, кажется финансы))
   на Java 2 кандидата, я + ещё джун(точно не с job4j т.к. вопросы базовые, а отвечал слабенько, на SOLID - вспомнил только S & L - кое-как описал)
   Начали с джуна (думаю взяли из расчёта закрывать простые задачки)

2 java dev
начали с другого кандидата
- Solid
- try-with-resources
- HashSet - поиск элемента Лучшее и Худшиее время
- spring - можем ли мы создать несколько бинов одного класса
- spring security - Авторизация и Аутификация - знаешь разницу?
- Чем занимался на последним проекте - Много типовых задач с Camunda.

Вопросы ко мне:
- Расскажи про прошлый проект? Что из [Интересно, Сложного, Примечательного]
  - Что делает проект? 
  - за что именно я был ответственен на проекте. (Большие фичи или важный функционал)
  - Это была Микро сервисная архитектура? (если да, опиши)
- Что такое распределённая транзакция? Как устроена, как работает, какие могут быть реализации?
- "Где ваши поды хостились? Это был свой кубик или ... как ваше приложение уходило в продакшен?"@Этот цитата - не удивляйтесь сленгу
- с Базой вы каким образом общались? Какая база и как вы строили общение с ней.
- Чем отличается SQL от HQL?
- Вопрос по ТЗ до собеса - Нет логики по Эксклюзивному Захвату данных - сейчас 2+ Шедулеров(Экземпляров сервиса) могут начать обрабатывать платежи с ид 1-10. (Это УЖАСНО), Как чинить?

После созвон кончился.
Важно не молчать, а рассуждать в слух, если не знаешь, делать предположения на основе того что слышал-видел.